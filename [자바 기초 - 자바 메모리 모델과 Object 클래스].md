### [자바 기초 - 자바 메모리 모델과 Object 클래스]



* 자바 메모리 모델 : 메소드 area / call stack / heap
* Object 클래스 : 11가지





#### 1. 자바의 메모리 모델

- 메모리 효율을 위해 메모리를 구분지음



①  method area

		-  구성 : 메소드 바이트 코드 / static 변수
		-  static은 프로그램이 종료될 때까지는 유지, 프로그램이 종료되면 소멸.



② call stack

- 구성 : 지역변수 / 매개 변수

- 제일 먼저 main이 들어오고(push), 그 안에 main의 지역 변수가 들어옴.

  그 다음으로 프로그램의 다른 함수들이 차곡차곡 들어옴.

- 메소드 실행이 끝나면 들어온 반대 순서로 하나씩 소멸됨 (pop). 

  각 함수의 지역 변수도 메소드가 소멸되면 같이 소멸됨.

- 프로그램이 종료되기까지 main만 남아 있게 됨.

  

③ heap

- 구성 : 인스턴스

- 인스턴스만 heap 영역에 들어가고, 인스턴스의 주소를 가리키는 참조 변수는 stack 영역에 있음(main의 지역변수)

- 인스턴스의 소멸은 참조 변수 초기화를 null로 했을 때.

  null로 초기화 되어 관계가 끊어진 인스턴스는 메모리만 차지하고 있는 상태. 

  이것을 정리해주는 역할을 하는 것이 '가비지 컬렉션(gc) (역시 객체)' (JVM 안에 있음)

- null은 곧 gc에게 해당 인스턴스를 처리해도 좋다고 알려주는 표시이기도 함.



#### 2. Object 클래스

1. finalize 메소드

   - 역할 :  인스턴스 소멸시 ''자동으로 호출''됨

   - 사용 방법 : finalize 메소드를 오버라이딩한 후, Object 클래스(부모 클래스)에 있는 finalize 메소드의 

     ​					구현 내용을 가져오기 위해 super.finalize(); 를 함께 명시 (이 메소드를 호출하기 위해서)

     ​					해주어야 함. 

      (오버라이딩은 부모 클래스의 같은 이름을 가진 메소드가 사라지고, 새로 구현 내용을 정의한 같은 이름의   자식 클래스 메소드만 남기 때문에 부모 클래스 메소드의 기능도 쓰고 싶다면, super로 부모 메소드 내용을 불러와야함)

     ```
        @Override
        protected void finalize() throws Throwable {		// Object 클래스의 finalize를
        													// 쓰겠다는 의미
           super.finalize();   					// 부모 클래스의 finalize 메소드 기능 호출
           System.out.println("destroyed: " + name);		// 자식 클래스에서 구현할 내용
        }
     
     ```

     

   - 오버라이딩 하는 이유 : 인스턴스가 소멸될 때, finalize 메소드 안에 명시한 명령을 실행해주기 위해.

   - 만약 super.finalize(); 를 호출하지 않으면, 인스턴스 소멸시 finalize 메소드가 자동으로 호출되질 x.

   - 실제로는 쓰일 일이 x (자바 최신 버전에서는 쓰지 않도록 권고함)

   

2.  equals 메소드

   - 목적 : 