[자바 기초 - 상속] [4. 객체 지향 - ② 상속 (inheritance)]



 * cf. 클래스 이름을 " xxUtils " 로 지으면 = 보통 해당 프로그램에 필요한 것들을 넣어 놓는 클래스라는 의미
 * cf. ★ 정렬 ★
	- 정렬 종류 : 버블 정렬, 퀵 솔트, selection, insertion 정렬 ...
	- 버블 정렬 :
        배열의 인덱스를 처음부터 바로 다음 인덱스와 차례대로 비교해서, 앞 수가 더 크면 자리 바꿈.
        다시 두번째 인덱스와 세번째를 비교해서 만약 앞 수가 더 크면 자리를 바꾸는데, 앞 수가 더 작으면 자리 바꾸지 않음.
        이렇게 한 바퀴 돌고 마지막에 온 수는 고정.
	      다시 한 바퀴 돌면 고정된 마지막 수 제외하고 나머지가 비교를 하고, 그 중 가장 큰 수가 마지막 수 전에 고정.
           ... 반복 ....
    	  ( = 오름차순 버블 정렬 )
        
     - 코드 ex.
          for(int i = 0; i < arr.length; i++) {
            for(int j = 0; j < arr.length - i - 1; j++) {		    // j 시작을 0으로 두고, j와 j+1을 비교하면
                                                                // 마지막 인덱스를 넘는 인덱스를 비교하게 되면 반복문이 끝나기 때문.	
              if(arr[j] > arr[j+1]) {
                int temp = arr[j+1];		// 메모리 하나를 할당 받아서(temp), 여기에 하나씩 넣고
                arr[j+1] = arr[j];			// 둘을 비교해서 더 큰 수로 바꾸는 방식
                arr[j] = temp;			    // ex. int a = 1    	둘의 값을 바꾸고 싶다면?
                                        //     int b = 2
                                        // ---------------------------------------
                                        //     int c = a	→  c라는 새 방에 a값 1을 넣어놓고
                                        //     int a = b   →  빈 a 방에 b값 2를 넣음.
                                        //    int b = c	→ b방에는 c에 넣어놓은 a값인 1을 넣음.
              }
            }
          }



② 상속 (inheritance)
 1. 용어 / 의미
   - 형태 : 자식 클랙스 + extends + 부모 클래스{ }
   - 상속을 하면 서로 다른 클래스에 있는 클래스 멤버와 메소드를 가져와 쓸 수 있음. 
   - 부모 클래스를 상속한 자식 클래스는 상속 받은 클래스 멤버와 메소드를 가지고 객체를 만들 수 있고, 해당 객체에서
      " 부모 클래스.메소드 이름(); " 형식으로 접근도 가능함.
   - 부모 클래스 = 상위 클래스 = 기초 클래스 
     자식 클래스 = 하위 클래스 = 유도 클래스

 2. 상속과 생성자
   - 이미 만들어진 부모 클래스는 마음대로 수정할 수 없음.
     Q. 그러면 부모 클래스를 상속 받은 자식 클래스는 부모 클래스의 멤버를 초기화하려면 어떻게 불러와서 사용할까?
     (심지어 부모 클래스의 멤버가 private 처리가 되어 있다면 접근은 아예 불가능.)
     
     A. 부모 클래스를 상속 받은 자식 클래스의 인스턴스를 만들고, 그 인스턴스가 main에서 호출되면
        ① 상위 클래스 생성자 실행 후
        ② 하위 클래스 생성자 실행됨
          → ex. A 클래스(부모 클래스) / B 클래스 (자식 클래스) / C 클래스(main 메소드)
                   생성자 a           /    생성자 b            /  B의 객체 ( = new B();  만 적어도 호출됨)
          → B의 객체를 메모리에 올리면, 생성자 b도 메모리에 올라가야 하는데
            이때 B 클래스가 A 클래스를 상속하고 있다는 걸 읽으면 먼저 A 클래스의 생성자 a를 호출한 후에 b를 호출함.
            (메모리에 부모의 멤버와 메소드가 먼저 올라가고, 자식이 그 다음에 올라감.)


   - this(); = 자기 자신 생성자 호출 메소드
     super(); = 상위 클래스 생성자 호출 키워드, 부모 생성자를 호출해 부모 객체를 생성함 
                 (생성자 첫 라인에 와야 함.)
     super. = 부모 클래스의 메소드 호출


   - 하위 클래스에서 상위 클래스 멤버를 초기화할 때, 직접 멤버를 초기화하는 것은 좋지 x(private 처리되면 접근 x)
     그래서 상위 클래스의 생성자(멤버가 파라미터로 들어가 있어서 접근 가능한)로 접근하는 것이 좋음.
     (ex. public 상위 클래스(상위 클래스 멤버) {
	        this.상위클래스 멤버 = 상위 클래스 멤버;
          }                                                               →이런 형태이기 때문에                           )
        → 그 방법이 " super(상위 클래스 멤버 이름); "


   - 단일 상속 / 다중 상속
      ① 단일 상속
         → 의미 : 하나의 클래스만 상속하는 것
         → 자바에서는 단일 상속만 지원함.
      ② 다중 상속
         → 의미 : 여러 클래스를 상속하는 것
         → 자바에서는 다중 상속 원칙적 금지. extends 키워드로는 하나의 클래스만 상속할 수 있음.
            ( ex. class C extends A, B  (X) )

   - 클래스 변수/메소드 상속
      → 프로그램에서 단 하나만 존재하는 static 변수/메소드를 상속할 수 있을까?
      → 부모 클래스의 생성자를 따로 super 키워드로 호출하지 않으면, 디폴트 생성자를 호출함
          (?? 부가 설명 필요 ??)

       * cf. static 도 private이 붙으면 다른 클래스에서 접근이 불가능해짐.

   - 객체 지향 특징 ① 정보 은닉화 - 접근 제한자 ② protected : 상속 받은 클래스에서 쓸 수 있는 변수/메소드라는 의미
 

 3. 오버라이딩(다형성의 핵심)
    ① 상속 관계를 나타내는 말
       - IS-A 관계 : 상속의 관계를 IS-A 관계라고 함. IS-A 관계여야 적절한 상속이라고 할 수 있음.
	                   객체 간의 관계이므로 상속으로 표현이 가능.

                        ex. class 스마트폰 extends 모바일폰
                                               ↓
                            "스마트폰은 모바일폰이다" 라는 의미 (" -는 -이다 " = " 자식 클래스는 부모클래스이다")

                        ex. 노트북은 컴퓨터이다 (o)
                           전기자동차는 자동차이다 (o)

       - HAS-A 관계 : "-는 -를 가지다" 로 해석해보면 쉬움.

                        ex. CPU는 컴퓨터이다 (IS-A관계가 X, HAS-A 관계 O)
                                      ↓
                            컴퓨터는 CPU, 메모리, 메인보드 등을 포함하고 있음.
                            즉, CPU는 컴퓨터가 가지는 여러 특성 중 하나.


     ② ★ 오버 라이딩 (오버로딩과 오버라이딩의 차이 알아 두기) (자바의 70%)★
         - 상속을 하고 자식 클래스의 객체를 생성하는 것은 앞서도 많이 연습해보고, 이미 알고 있는 내용.
             → " 자식클래스 변수이름 = new 자식클래스(); "
         - 그런데 " 부모클래스 변수이름 = new 자식클래스(); " 도 에러가 나지 않고 사용 가능
             → ★ 이것이 바로 "다형성" ★
	        (객체 지향 프로그래밍 언어에서 다형성은 '여러 가지 형태를 가질 수 있는 능력'을 의미하며,
		Java에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 프로그램을 구성한다.)
             → ★ 다형성이란 ? " 부모 = 자식 (without 형변환) " ★
             → 상속을 받게 되면 타입이 달라도(부모 클래스 타입, 자식 클래스 타입) 객체 생성 + 참조 변수로 접근 가능.
             → 기본적으로 타입이 다르면 형변환을 반드시 해야 하지만, 다형성에서는 형변환이 필요 x.
             → " 자식클래스 변수이름 = new 부모클래스(); "  ------------------------------- X (에러남)
				                  ↓
			                자식 = 부모           -------------------------------- X (역순은 적용 X)

             → 이유 :
                          [ 부모클래스 변수이름 = new 자식클래스(); ]
                                                ↓
                부모 클래스를 상속 받은 자식 클래스의 인스턴스를 생성하면, 메모리에는 부모 - 자식 순으로 인스턴스가
                만들어짐. 이렇게 부모 클래스의 멤버+함수와 자식 클래스의 멤버+함수를 모두 가지고 있는 상태에서
                부모 클래스 데이터 타입을 받는 변수를 이용해 부모 클래스를 불러오는 것은 당연히 가능.
                =============================================================================================
                          [ 자식클래스 변수이름 = new 부모클래스(); ]
                                                ↓
                어떤 상속도 받지 않은 부모 클래스의 인스턴스를 생성하면, 메모리에는 부모의 인스턴스만 있는 상태.
                이때 인스턴스가 생성되지 않아 어떤 정보도 없는 자식 클래스의 데이터 타입을 받는 변수를 이용해
                자식 클래스의 정보를 가져오는 것은 당연히 불가능.

             → " 부모 = 자식 " 이기만 하면, 배열 생성도 똑같은 방법으로 할 수 있음.


         - 메소드 오버 라이딩 (다형성을 통해 구현해낼 수 있는 기능)
             → 상속을 했는데 부모클래스의 메소드 이름과 자식 클래스의 메소드 이름, 리턴타입, 파라미터까지 같은데
	             그 안에 담긴 내용(구현 내용)만 다르다 ?  
                 --------------------------------------------->  "메소드 오버 라이딩 (= 덮어 쓴다)"
                 
             → 오버 로딩 : 메소드 이름, 리턴 타입이 같고 / 파라미터가 다름
	             오버 라이딩 :  메소드 이름, 리턴 타입이 같고 / 파라미터도 같음
               
             → ★ 오버라이딩은 자식 것 ★
            	 (부모의 함수는 자식의 함수를 덮어 씀 → 자식의 함수가 호출됨)
	             ( 결국, 어떤 클래스 인스턴스로 접근하든 최종 자식에 있는 같은 이름의 함수가 호출되는 것)
               
             → 호출 방법 : 인스턴스 외부에서 호출하는 방법은 x. 그러나 인스턴스 내부에서는 키워드 super를 통해 호출 가능.
		                 
             → 그렇다면 각 클래스의 인스턴스 변수, 클래스 변수도 오버라이딩 될까?
	             A. 인스턴스 변수는 오버라이딩 되지 x
                  ( 참조변수 데이터 타입에 따라 접근하는 곳이 정해짐.)
		              ( 속한 각 클래스 메모리에 올라가는 것)

    ③ instatnceof 연산자
