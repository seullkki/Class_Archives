[자바 기초 - 2. 객체 지향(OOP)]



① 참조 변수에 null 대입
   - 참조 변수 : 참조형 + 변수 이름 = 보편적인 객체 생성 의미
   - null = 청소부 = 비웠다, 지웠다는 의미의 데이터 = 기존 데이터를 지워버리고 초기화 상태로 만듦
   
   - 참조 변수 안에 null 대입 : " 참조형 + 변수 이름 = null; " 
                                  → 참조 변수에 null을 대입하는 초기화를 하는 것
                                  → 변수가 참조하는 인스턴스와 관계를 끊는다는 의미
                                  → 변수에 주소가 없는 상태 = 객체가 생성되지 않은 상태 = 객체가 없는 상태
                                  → 'null 체크' 라고도 함
                                      (if문으로 != null 이면, 명령을 실행하도록 함 / null인 경우를 거르는 방법)
                                      (★ 대표적으로, 참조형 변수를 함수의 매개 변수로 쓰는 경우는 반드시 null 체크를 해야 함 ★)
                                      (ex. 지역 변수도 null임을 표시하고 null 체크를 해주는 게 좋은 코드
                                           public static void main(String[] args){
                                              Rectangle ref = null;           // main 메소드의 지역변수
          
                                              if (ref != null){ 
                                                 ref.setRectangle();
                                              }
                                           }                                                                  )
                                  →   if ( ref != null) : 변수 ref가 참조하는 인스턴스가 있다면...
                                      if ( ref == null) : 변수 ref가 참조하는 인스턴스가 없다면...
                                  → 자바에서 null은 참조형 변수를 초기화할 때 사용.
                                    따라서, 기본형 변수(8개 데이터 타입)에는 사용할 수 x.



② String 클래스
  - 문자열을 다루는 클래스
  - String은 클래스로, 자바 자체에 들어 있는 클래스임.
  - String은 클래스이므로, 참조형 데이터 타입이고 / 변수와 함께 쓸 때, 주소를 받으며 / 크기는 4바이트임
     →  ex.
               char ch = '가';
               System.out.println(ch + '\n') 는 연산되고,

               System.out.println(ch + "\n") 는 출력되는 이유?

                -> ch + "\n"는 연산을 위해 메모리에 올라가면, 데이터 타입을 먼저 맞춰야 하는데
                   '2바이트 + 4바이트'이므로 String으로 형변환되어 연산됨.
                   즉, "ch" + "\n"이라는 결과가 출력됨
                
               System.out.println(5 + 7 + "\n");                -> 5+7 먼저 연산 / 12 + " " / "12" + 개행

               System.out.println(5 + 7 + "\n" + 8);            -> 5+7 / 12 + " " / "12" + " " + 8 / "12" + 개행 + "8"

                                                                        

  - String을 사용하면, 문자열을 추가해서 인스턴스들을 서로 구분할 수 있는 정보들을 넣을 수 있음
    (cf. 각 인스턴스를 구분할 수 있는 정보가 포함되도록 클래스를 만드는 게 좋은 클래스를 만드는 방법 )
    (ex. 계좌 확인 클래스에서 계좌번호, 주민번호를 입력하는 String 클래스를 추가
          → 여기에 값을 넣는 방법으로 getter/setter 대신 초기화 함수를 따로 만들 수 있음
          → 초기화를 위해 생성자 함수를 활용
          →  ex.  class BankAccount{
                       String accNumber;         // 계좌 번호
                       String ssNumber;          // 주민 번호
                       int balance;              // 예금 잔액

                       public BankAccount(String acc, String ss, int bal){              // 생성자
                          accNumber = acc;
                          ssNumber = ss;
                          balance = bal;                                           -> 4줄 : 초기화를 위한 생성자
                    }                                                                                                )
           → 생성자는 값을 반환 x, 반환형도 표시 x




③ 생성자
  - 생성자 함수
     * 형태 : 클래스 이름과 똑같은 함수
     
     * 용도 : 객체를 만들 때 사용 =  new 뒤의 함수가 바로 '생성자 함수'
              (cf. 멤버로 인스턴스 고유의 정보를 가지도록 하자 = 좋은 클래스
                   -> 고유한 정보를 의미할 만한 멤버(변수)를 선언하고 + 적당한 값을 넣어줘야 함(초기화)
                   -> 그 초기화를 가능하게 해주는 문법 = 생성자)
              (cf. 대부분의 클래스는 디폴트 생성자보다 직접 생성자를 적어주는 것이 좋음.
                   -> 클래스 안에는 반드시 데이터가 있고, 메소드가 있음. = 데이터가 있다는 것은 그 값을 필요한 값으로 초기화해줘야 한다는 의미.
                       = 생성자로 입력해줘야 함
                   -> 설사 초기화가 필요 없더라도 명시적으로라도 초기화 값이 0이라는 것을 생성자를 만들어서 명시하는 것이 좋음)
                       
                        
     * 특징  → 생성자 함수는 클래스 이름과 같은 이름을 씀. 
             → 리턴 타입이 x  =  리턴값이 x
                 ( Q. 왜 리턴 타입이 없을까?
                   A. 함수의 용도를 제한하기 위해서.
                   리턴값이 있다면, 그에 따른 리턴 타입이 여러 가지 올 수 있는데 이것을 막아서 사용 범위를 제한하기 위함.
                   연산을 위한 함수가 아니라, "초기화" 용도로 사용하기 위해 리턴 타입을 주지 x.)

     * cf. 매개변수로 모든 필드를 초기화 하는 생성자 = 디폴트 생성자에 매개변수를 넣어서 객체의 생성자로 직접 값을 입력할 수 있게 됨.
                                                    = 좋은 클래스를 만들기 위해 인스턴스마다 구별되는 정보를 넣어주려면,
                                                      인스턴스를 만든 다음 처음에 해당 정보를 넣어주는 '초기화'가 필요.  
                                                    = 이 정보들은 인스턴스 생성 후 딱 한번만 호출되어야 하는 정보들임 
                                                    = 이것을 행해주는 메소드를 '생성자'라고 함.
                                                    
             → 출력 메소드에서는 원하는 필드를 순서 상관 없이 가져와 사용하면 되지만,  생성자의 매개변수 순서는 양쪽이 같아야 함.
               (java_rec : tv / tvResult 자바 파일. person / personResult, song/sontresult 참고)

     * cf. 생성자를 직접 생성하면, getter/setter가 없어도 객체에 인자를 입력함으로써 입력값을 출력할 수 있지만,
           해당 클래스와 객체를 언제, 누가 접근해서 사용할지 모르기 때문에 getter/setter는 무조건 생성해두자.
            → getter/setter를 생성하면 getter/setter가 없을 때 변수 이름으로 직접 입력값을 불러오던 것을 get/set 함수로 불러올 수도 있음.
              get/set 함수로 자기 자신의 값을 불러오는 것임.
    
     * cf. << java_rec.src.java_rec.Game/  java_rec.src.java_rec.GameResult 파일 참고>>
     
	          AutoSum 클래스에 getter/setter를 만들고, 객체 생성자에 직접 값을 넣지 말고
          	AutoSum.setNum1(값); / AutoSum.setOp(값); / AutoSum.setNum2(값); 를 따로 주어도 똑같이 작동함.
          	(= 객체 생성 실습 처음할 때, 썼던 방법)
	          이때는 AutoSum 클래스에 디폴트 생성자가 있어야 함.
            
            → Q. 생성자를 통해 값을 초기화하는 것 vs getter/setter를 통해 값을 초기화 하는 것의 차이?
              A. getter/setter 는 컴파일 하는 순간, AutoSum 클래스의 멤버와 메소드를 메모리에 올려서  만들어진 "하나의 객체에" 
                 계속 값을 바꿔 넣어주는 것임.
          
                 생성자를 이용하는 것은 컴파일하는 순간, 메모리에 객체를 올려서 값을 입력하고 연산까지 한바퀴를 돎.
                 그리고 다시 값을 입력하면 같은 구조로 된 "새로운 객체를 만들어" 값이 넣어지고 연산을 진행함.
                 즉, 값을 넣을 때마다 새 인스턴스가 생성되는 것임.
                 
              A. 생성자를 이용하는 경우, 실행을 할 때마다 메모리에 계속 쌓이는 것. 
                 예전과 다르게 지금은 이 메모리를 JVM이 관리해서, 메모리에 쌓인 필요 없는 메모리들을 알아서 지워주고 관리함.
                 그러나 JVM이 관리를 해주어도, 쌓인 메모리를 지울 때 컴퓨터 성능이 떨어질 수 있음.
                 따라서, getter/setter를 이용하는 것이 생성자를 이용하는 것보다 메모리 차원에서는 더 좋음.
            

  - 디폴트 생성자 
      * 컴파일러가 자동으로 삽입해주는 생성자
      * 생성자를 내가 만들지 않았는데도, 객체 생성 시 에러가 나지 않는 이유?
        ( 지금까지 모든 예제에는 따로 생성자 함수를 만들지 않았지만, 문제 없었음.)
        = 컴파일러가 자동으로 생성자를 만들어 주었기 때문.
      * 형태 : public 클래스이름 ( ) { // 내용 공백 상태 }
       → cf. public은 써도 되고, 안 써도 됨
      



④ Scanner
  - 입력을 직접 받을 때 사용 (학습용, 실무에서는 거의 쓰지 x)
  - import java.util.Scanner;
    Scanner scanner = new Scanner(System.in);              → System.in 은 "키보드" 입력을 받는다는 의미
    
    int num = scanner.nextInt();                           → 정수값을 입력받고 있다가, 빈칸(엔터)를 받는 순간, 변수에 받은 값을 쏟아 냄
                                                                  
    String name = scanner.next();                          → 문자열을 입력 받음

    System.out.println(num);
    System.out.println(name);

Q. scanner.close(); 를 쓰는 방법을 모르겠음?


④ 자바의 이름 규칙
  - 클래스 : 첫 문자 "대문자"로 시작 / 합성어의 첫 글자 "대문자" (낙타등 표기법)
  - 메소드 : 첫 문자 "소문자" / 합성어 첫 글자 "대문자" (낙타등 표기법)​
  - 변수 :  첫 문자 "소문자"/ 합성어 첫 글자 "대문자" (낙타등 표기법)​​
  - 상수 : 전체 "대문자" / 합성어는 _ 로 연결 (뱀 표기법)
  

