[자바 기초 - 연산자(operator)]



 - 주의 사항: 우선순위, 결합 방향  →  우선순위가 같을 경우. 결합 방향은 왼쪽 > 오른쪽
             ① 우선 순위가 가장 높은 것 = ( )
               (ex. short num = 7;
                    num = (short)(num + 77L);

                    System.out.println(num);
                    
                → = 연산자는 오른쪽에서 왼쪽으로 결합한다는 것이 중요.
                → ① 7이 num에 대입됨
                  ② num에 대입된 7이 두 번째 소스코드 오른쪽 num에 들어감
                  ③ 두 번째 소스코드 왼쪽 num에 최종적으로 대입된 값이 출력됨 ) 

             ② && 연산, || 연산의 진행 원리
               (ex. 
		                int num8 = 0;
		                int num9 = 0;
	                	boolean result1;
		
		                result1 = ((num8 += 10) < 0) && ((num9 += 10) > 0);   →  = 연산은 오른쪽에서 왼쪽이지만, 
                                                                             && 연산 안에서는 왼쪽에서 오른쪽으로   
                                                                                                                                                 순서대로 진행
                		System.out.println("result = " + result1);
	                	System.out.println("num8 = " + num8);
	                	System.out.println("num9 = " + num9 + '\n');  

                    → ① (num8 += 10) < 0) 먼저 진행 → false
                      ② && 연산의 첫 번째 연산이 false로 나왔기 때문에, 바로 출력문으로 나가게 됨
                      ③ result1 = false , num8 = 10, num9 = 0

                      cf. || 연산이었고, 첫 번째 연산식이 (num8 += 10) > 0 였다면, true가 먼저 나왔기 때문에 역시
                          연산식이 종료되고 출력문으로 나가게 됨




1. 산술 연산자 : +, -, *, /, %



2. 대입 연산자 : =, +=, -=, *=, /=, %=, &=, |=, ^=, >>=, <<=, >>>=
  → 연산 시 강제 형변환이 필요하지만, 자바가 임의로 형변환 후 연산해줌
    (ex. int num = 10;
         System.out.println(num += 3.5);
         → 결과 : 13
         → 10 + 3.5 는 double 형으로 변환되는데 num이라는 그릇이 int 형이므로, 자바가 알아서 (int)(10 + 3.5) 형변환한 후 출력)



3. 비교 연산자 : ==, >, <, >=, <=, !=



4. 증감 연산자 : ++, -- 
  → [ i ++, --  ] : i = i + 1 
                    (연산하지 않은 값을 먼저 대입한 후, +1,-1 연산해서 뒤에 진행되는 코드에 +1,-1)
                    ex.     int num = 5;
                       
                             System.out.println(num++);  6     →  5 (★ 먼저 대입 후, 하나의 실행 단위가 끝나고 난 뒤 +1이 되므로, 5)
                                                 5       +1               
                             System.out.println(num++);  7     →  6 ( 앞의 5  + 1 한 결과 = 6)
                                                 6       +1
                             System.out.println(num);          →  7 (6 + 1 = 7)

                    ★ 하나의 실행 단위 = CPU갔다 왔다 = 연산이 한번이라도 진행됐다

  → [ ++, -- i ] : i = i + 1                        7
                   (+1, -1 연산을 먼저 한 다음 연산한 결과로 다음 코드 진행됨.)
                    ex.     int num = 5;
                       
                             System.out.println(++num);   →  6
                             System.out.println(++num);   →  7
                             System.out.println(num);     →  7
    =====================================================================================
       ex.  
	        	int num1 = 7;
	        	int num2 = 3;
	        	int result;
		
	         	result = (++num1) - 5;           →  num1 + 1이 () 안에 들어감
        		System.out.println(result);
		
	        	result = (num1++) - 5;           →  num1 = 8이 먼저 들어가 연산, result 대입 모두 진행 후, +1
	        	System.out.println(result);           만약 다음 출력에 num1이 있다면 9로 시작

   =====================================================================================
       ex.  int x = 10;                                * 우선순위 : 증감 > 산술

             int y = x-- + 5 + --x;                    * 증감연산자의 우선순위가 더 높기 때문에,
                     ---       ---                      먼저 1, 2 증감 연산자를 계산함
                     ① 10   →  ② 8
              [넘어가면서 -1 되어 ②에 들어감]
                     -------------
                           ③  10 + 5 + 8 = 23
                            
            System.out.println(y);


 ★ 증감 연산자는 +1을 한 후에 " 대입 "까지 포함한다는 것을 잊지 말 것




5. 논리 연산자 : &&, ||, !
  → 주의 사항 : && 연산은 먼저 false가 나오면 / || 연산은 먼저 true가 나오면
                   뒤에 남은 연산으로는 가지도 x



6. 비트 연산자 : &, |, ^, ~, >>, <<, >>>
  → cf. 컴퓨터의 기본 단위 = bit
          bit - byte(8bit) - KB( 2의 10승 * byte = 1024byte) - MB(2의 10승 * KB = 1024KB) - GB - TB ...
  → & : 비교할 두 bit가 있을 때, 대응되는 각 bit 자릿수가 모두 1 / 0 이어야 1 / 0 반환
  → | : 대응되는 각 bit 자릿수가 둘 중 하나라도 1이면 1 반환, 둘 다 0일 때만 0 반환
  → ^ : 두 bit가 서로 다르면 1 반환, 서로 같으면 0 반환
  → ~ : 1은 0으로, 0은 1로 반전
  → >> : 오른쪽 방향으로 자릿수를 한 칸 씩 밂 / 이동으로 빈 왼쪽 비트들은 기존값이 음수였다면 1로,
                                                       양수였다면 0으로 채워 부호를 유지함.
           (ex. 11111000 >> 1 = 11111100  =  10진수화 : 원래값 * 1/2의 n승 = -8 * 1/2 = -4)
  → << : 왼쪽 방향으로 자릿수를 한 칸 씩 밂 / 이동으로 빈 오른쪽 비트들은 0으로 채움
           (ex. 00000010 << 1  =  00000100  = 10진수화 : 원래값 * 2의 n승 = 2 * 2의 1승  = 2의 (n+1) 승= 4            
                00000010 << 2  =  00001000
                00000010 << 3  =  00010000                                                               )

  * 주의 사항 : 비트 연산자도 연산이기 때문에, int 이하의 데이터타입이 비트 연산으로 연결되면 int로 형변환 되므로 반드시 강제 형변환 해줘야 함
                 
  * cf. -1  =  11111111;
        0   =  00000000;



7. 부호 연산자 : +, -
  → ex. short num = 7;
          short num1 = +num;  -------------------------------------------------  에러
          (부호 연산자가 붙는 순간, 컴퓨터는 연산으로 인식 = (1 * 7) 이라는 연산이 됨
                                       → +7이 int가 됨 = 메모리에서 int로 자동형변환)
          (int 값을 short에 넣으려고 하니 에러가 남. 따라서 아래와 같이 형변환을 해주어야 에러가 없어짐)
  
           short num1 = (short)(+num);


8. 기타 연산자: 삼항 연산자( ? : ), instanceof 연산자
