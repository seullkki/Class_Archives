[자바 기초 - 5. 객체 지향(OOP)]



① 클래스 변수 / 클래스 메소드

 《 클래스 변수 = 'static' 변수 = 공유 변수 = 정적 변수 》

  - 여러 클래스를 만들고 만든 모든 클래스에서 공통으로 적용되는 변수를 만들고 싶을 때,
    이 변수는 클래스마다 생성될 필요가 없을 것이고 한 번만 써서 모든 클래스에 적용되도록 하고 싶을 수  있음. 
   
  - 형태 : static + 변수 선언

  - cf. 사용 예시 : 홈페이지 전체 방문자는 static 처리해서 접근 방식을 하나로 해야 함.

  - memberevar 플래시 파일 참고 / 이해 x, 외우기

  - 작동 원리(어떻게 메모리에 데이터를 올리는가 / 왜 = 연산을 하기 위해):
        1. 컴파일 후 .class 파일을 실행하면, JVM에 의해 main 메소드가 ② 영역에 호출됨.

        2. 클래스의 객체를 생성하기 위해 new 키워드가 읽히기도 전에
           ① 영역에 클래스에 대한 정보( = 함수에 대한 2진수 정보)가 올라감.
           동시에 스캔한 정보 중에서 static 변수를 찾아 ① 영역에 static 변수 방을 만들고 주어진 값을 대입함.
           + 클래스의 static 함수도 ① 영역에 방을 만듦.
             ( ③ 영역에서 함수를 호출하면 함수가 가리키는 주소를 따라 ①영역의 함수로 연결됨)
             (ex. 힙 영역에서 set함수를 호출한다는 것은, set함수가 가리키는 주소만 있는 상태로, 메소드 영역의 set함수로 연결된다는 의미)
                    
        3. ② 영역에 호출된 main 함수 안에 객체를 만들기 위한 참조 변수의 방이 만들어짐.
           (참조 변수는 main 메소드의 지역 변수이기 때문)
           (cf. main 메소드는 static. 이 안에 변수 선언을 하면 에러 x =  static 메소드에 인스턴스 변수를 가져온 것이 아니라,
                main 메소드의 '지역 변수'이기 때문.
                만약 클래스에 선언된 인스턴스 변수를 main 메소드 안에 초기화 하려 한다면 에러가 남. 
                이때는 인스턴스 변수에 static을 붙여야 에러가 사라지게 됨.)
      
        4. new 키워드가 작동하면서 ③ 영역에 객체가 만들어짐
           (클래스 내용에 따라 인스턴스 변수 방이 할당됨 + 주소값 부여됨 + ② 영역에 있는 참조 변수에 객체의 첫 번재 주소값이 들어감 
            = 우리가 아는 인스턴스)
           → 여기서 static 변수의 방은 만들어지지 x, 인스턴스 변수 방만 만들어짐.
           → 대신 static 변수 방이 있는 ① 영역의 주소(4바이트)를 가리키고 있는 상태가 됨.
           → ③ 영역에서 인스턴스 변수에 값이 들어가기 전 참조형 변수의 초기화 값은 "null", int형은 "0"
           → 인스턴스 메소드도 ③ 영역 인스턴스 안에 있음.
      
        5. 객체의 인스턴스 변수에 입력된 값이 들어감.
      
        6. 만약 같은 클래스를 이용해 인스턴스를 여러 번 만든다면, 이미 ① 영역에 클래스 정보가 있으므로,
           정보를 또 올리지 않고 가진 정보를 이용해 인스턴스 생성.
           → 이때 클래스가 가진 static 변수는 역시 ① 영역에 있으므로, ① 영역의 같은 주소를 가리킨 상태가 됨.
      
        7. ② 영역에는 코드 진행에 따라 함수가 쌓이게 됨( = 콜(함수) + 스택(쌓이다))
           → 함수는 실행된 후 종료되므로, 종료된 함수는 ② 영역에서 사라짐
               (ex. println 함수는 출력 실행을 끝내면 ② 영역에서 사라짐)
      
        8. 만약 코드 진행 중에 static 변수에 새로운 값을 대입하는 경우가 생기면, 
           static은 ③이 아닌 ① 영역에 있으므로 static을 가리키는 주소값을 따라 ① 영역에 있는 static의 값을 바꿈.
           (값의 재할당이 아닌 연산이라면, 원래 static 변수가 가진 값에 추가로 연산이 이뤄짐)
      
        9. main 메소드의 모든 코드가 진행되면 main 메소드는 종료되고 ② 영역에서 사라짐. + 프로그램 종료
      


  - static 변수에 접근 하는 방법 (이유 : static 변수의 값을 알고 싶어서 변수를 불러오기 위해)
    1. static이 들어있는 클래스 객체화 후, " 참조 변수.static 변수 이름 "
    
       → 클래스가 객체화 될 때 ① 영역에 있는 static 변수를 가리키는 주소값이 생기는데, 변수가 가리키는
         객체 주소로 먼저 가서 + static 변수를 가리키는 주소로 다시 이동해서 + static 변수로 접근하는 방식.
       → 1은 좋은 방법이 x. static에도 private 접근 제한자를 붙이면 이 방법으로 접근 x.
   
    2. static이 들어있는 , " 클래스 이름.static 변수 이름"

      * 2번 방법을 써야 명시된 내용만 보고도 해당 변수가 static 변수임을 알 수 있기 때문.
        1번 방법은 인스턴스 변수를 호출할 때도 사용하는 방법이기 때문에, 그것이 인스턴스 변수인지 클래스 변수인지 알 수 x.


   
  - 클래스 변수의 초기화
    ① 시점 : 변수 선언을 하자마자 초기화하는 것이 가장 좋음
             (static 변수는 생성자에 초기화하면 x. 인스턴스를 만들 때마다 값이 리셋되기 때문) 
             
    ② 방법 : static 변수가 들어가는 클래스 이름.static 변수이름 = 상수;(= 접근 방법)
              (Q. 이것이 메모리에 올라가는 시점 ? 클래스 이름만 적어도 클래스 정보를 메모리에 스캔)

  - 모든 클래스에 공통적으로 적용되는 final 상수 같은 경우나 그 외의 경우들도 static을 붙여서 변수를
    만드는 것이 좋음.

  - 사실상 static은 모든 클래스에 적용되는 것이기 때문에 static을 실제 명시한 클래스와는 관련이 없고
    자리만 빌려 표기한 것임.(자바에서는 모든 코드가 무조건 class 안에 들어가야 하기 때문)




 《 ★ 클래스 메소드 = 'static' 메소드 》
                                   
 - 형태 : static + 메소드

 - 접근 방법 : 객체.메소드(); or 클래스.메소드();
 
 - 예시 : System.out.println();                       = 단순 기능 제공이 목적인 메소드 = 객체가 필요 x
          ------ ---                                  = 쓸 때마다 객체를 생성할 필요가 x (new 사용 x)
             |      ↓                                 = static 메소드로 만들어 사용하고자 할 때마다 직접 접근할 수 있도록 함.
             |   static 변수 이름                     = 별도의 객체 생성 없이 클래스 이름만으로 접근이 가능.
             ↓                                        
           static 
     (클래스로 접근하고 있기 때문)


 - ★ 클래스 메소드와 인스턴스 변수는 서로 전혀 관련이 없는 별개의 존재.
   = static 메소드에는 인스턴스 변수/메소드가 올 수 x
   = 인스턴스 변수/메소드에는 static 변수/메소드가 올 수 o
                           ↓
   이유 : 메모리에 올라가서 방을 할당 받는 시기가 서로 다르기 때문.
          (static 메소드 안에 인스턴스 변수 or 메소드가 있는 소스코드 일 때, static 메소드는 메소드 영역에 먼저 생성되고,
           인스턴스 변수와 메소드는 힙 영역에서 나중에 인스턴스를 생성한 후 메모리에 할당되기 때문에
           static 메소드에서는 인스턴스 변수, 메소드가 만들어지지도 않았기 때문에 사용할 수가 x)
           
          ( ex. private int num1; (인스턴스 변수)
    
                public static int getNum1(){
                        return num1;                      -> 에러남
               }                                            (static 메소드에서 인스턴스 변수로 접근하는 것은 x)

 - main 메소드가 pulic + static인 이유?
   ① static인 이유 : 인스턴스 생성과 관계 없이 제일 먼저 호출되는 메소드
   ② public인 이유 : main 메소드의 호출 명령은 외부에서 먼저 시작되기 때문

 - cf. 클래스에 자기 자신의 참조 변수가 와도, 해당 참조 변수가 가리키는 새로운 객체의 주소값이 와 있을 뿐임.
             
 - cf. main 메소드는 static. 이 안에 변수 선언을 하면 에러 x =  static 메소드에 인스턴스 변수를 가져온 것이 아니라, main 메소드의 '지역 변수'이기 때문.
       만약 클래스에 선언된 인스턴스 변수를 main 메소드 안에 초기화 하려 한다면 에러가 남.
       이때는 인스턴스 변수에 static을 붙여야 에러가 사라지게 됨.
       ★ main 메소드 안에 있는 것들은 모두 "지역 변수"임.

 - 다른 용도의 static 선언 : static 초기화 블록
   static {
         LocalDate nDate = LocalDate.now();           → 초기화를 딱 한 번 실행하고 사라짐
         date = nDate.toString();
   }

 - static import : import + static.패키지.클래스.변수이름;
                   → ex. Math.PI; 라고 불러오던 static 변수는
                         import static java.lang.Math.PI;  으로 불러와서 PI로만 쓸 수도 있지만, 거의 쓰지 X.


                                                   
  
   
