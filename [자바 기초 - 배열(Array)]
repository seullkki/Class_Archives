[자바 기초 - 배열(Array)]



* 코딩 시험에서는 많이 나오지만, 실무에서는 거의 쓰지 x.
* 배열을 기반으로 만든 '컬렉션 프레임(자료구조)' 등을 실무에서 많이 씀.


1. 1차원 배열
 - 의미 : 데이터 타입이 "같은" 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간
          (하나의 메모리 공간을 나란히 할당 받고, 그 안에 들어갈 데이터 타입은 모두 같은 타입이어야 함.)
          (1차원 : 나열 형태가 선의 형태로 = 一 형태로 생긴 배열)
          (1차원 배열 : 일렬로 나란히 할당된 변수들의 모임)

 - 형태 : 데이터 타입 [] 변수 이름 = new 데이터 타입[들어갈 데이터의 개수];
          -----------------------   ------------------------------------
                 ↓                                      ↓
             배열 선언                       배열 생성 / 값을 저장하는 방법

 - 메모리에 변수 이름으로 된 메모리를 할당 받는데,
   이 메모리의 데이터 타입은 '데이터타입 배열' / 메모리에 들어가는 값은 '4바이트 주소값'
    → 데이터 타입이 배열이라는 것은 '참조값'이라는 것이고, new는 객체를 생성하는 것이므로 값은 주소값이 들어갈 것임을 추측할 수 있음.
       
 - ex. int[] ref = new int[5];
       → 메모리에 정수형 배열을 담을 수 있는 ref라는 방을 만드는데, 5개의 정수가 들어갈 수 있는 만큼의 공간을 할당 받음 (= 총 20 바이트)
       → 이 공간은 연속된 공간으로 이루어져 있음 = 예를 들어 첫 번째 주소가 1000번지라면, 마지막 주소는 1020번지.
           
 - ★ 배열은 메모리를 할당받을 때 "연속된 공간"을 할당 받음.
 
 - 배열도 인스턴스이므로, 그 안에는 인스턴스 변수/메소드가 들어있음. 
   '배열 이름.length'를 출력하면 배열의 길이가 출력됨. (= 배열의 인스턴스 멤버인 length를 호출(.)한 것)
    (위에서 말한 나란히 할당 받은 메모리는 배열의 인스턴스 안 공간에 할당된 것이고, 이 인스턴스 안에는 인스턴스 멤버/메소드 등이 있음.)
    
 - 참조형을 데이터 타입으로 받는 배열
   → 이 배열은 배열 길이 * 참조형 4바이트 만큼의 연속된 메모리를 할당받게 됨.
       4바이트 하나의 메모리 당 들어가는 값은 각 '주소값'.

       ?? 즉, 참조형의 각 인스턴스가 각 메모리를 가리키는 형태가 됨. ?? 
        Q. 혹시 참조형 배열에 들어가는 값이 String일 때만, 이런 형태인가?
           String은 인스턴스이니, " "값을 넣는다고 해도 " " 하나 하나가 인스턴스라서?

 - 인스턴스 변수에 아무 값도 초기화되어 있지 않은 경우라면, 컴파일러가 각 타입별 기본값을 넣어줌.
    → 참조형 = null
      int / float / double 형 = 0 / 0.0
    → 기본값으로 초기화한 후 print/println은 자동으로 toString을 호출해 값을 불러옴.

 - 접근(참조) 방법 : 배열 [인덱스 번호];
                     → 인덱스는 " 0 "부터 시작
                     →  배열 [인덱스 번호] 그대로 출력하면 해당 인덱스에 있는 값을 출력함.
                        배열 [인덱스 번호] = 값; 은 값을 해당 인덱스 자리에 넣어준다는 의미. 

 - 배열은 반드시 반복문과 함께 쓰게 되어 있음
     → ★ 참조변수.length 와 참조변수[반복문 i].length() 의 차이
        ① 참조변수.length : 배열 인스턴스의 길이
        ② 참조변수[반복문 i].length() : 배열의 해당 인덱스에 들어있는 Sring 값의 길이

 - 배열 생성 / 초기화
  → 생성 : int[] arr = new int[3];
             (배열 선언 시에는 개발자가 반드시 배열의 크기를 입력하도록 되어 있음)
             ( 배열 선언 방법 ① int[] arr (더 많이 선호하는 방법) / ② int arr[] (c언어 방법) )
  → 초기화 : int[] arr = new int[] {1, 2, 3};
                (초기화에서 [] 인 이유 = 초기화한 값의 크기 만큼 컴파일러가 입력해주기 때문)
                <<간결화>> int[] arr = {1, 2, 3};

 - 메소드의 매개변수로 배열의 참조값이 올 수 있음 (= 배열이 매개변수로 올 수 있음)
 - 배열을 리턴값으로 메소드를 만들 수도 있음.  

 - 배열을 선언하고 크기를 정해 생성한 후에 초기화를 하지 않으면, 컴파일러가 기본 값을 초기화해줌.
     → 참조형 = null
       나머지 기본 타입 = 0
       
 - 배열의 초기화 / 복사
   → Arrays.fill(); / System.arraycopy();
   → 둘 다 static 메소드이기 때문에 각각 Arrays / System 클래스를 통해 접근 가능함.
   → Arrays.fill(배열 참조변수, 초기화할 값);  :  해당 배열 전체를 입력한 값으로 채워줌
   → System.arraycopy(배열 1, 인덱스 값1, 배열 2, 인덱스 값2, 개수);  :  배열1의 인덱스 값 1부터 '개수'만큼의 값을
                                                                        배열 2의 인덱스 값 2부터 넣음.


 - enhanced for문 (enhanced : 강화한, 높인)
   → 배열 + for문은 반드시 함께 쓰는 조합인데, 이것을 묶어서 '강화된 for문'을 만든 것.
   → 형태 : for( 배열 데이터 타입 + e : 배열 이름 ) {
                   System.out.println(e);
              }
                                  |
                                  ↓ 원래 형태
                                  
              for( 배열 데이터 타입 e ; e < 배열이름.length; e++){
                          ............
              }
   → 원리 : 사용할 배열에 들어 있는 값을 첫 번째부터 하나씩 e에 저장 + 출력
            (첫 번째 값이 들어가서 저장 + 출력되면, 그 다음 값으로 넘어가 저장+출력....)
   → 참조형 배열을 enhanced for문에 적용할 때?



2. 다차원 배열
 ① 2차원 배열
   - 형태 : int[][] 배열이름 = new int[행의 수(가로)][열의 수(세로)]
   - 접근 방법 : ex. int[][] ar = new int[3][4]
                    → 3행 x 4열 짜리 배열 (실제로는 메모리에 연속된 공간이 할당되는 것이지만, 이해를 위한 표현)
                    → ar[1][2] = 1;  :   1행 2열에 1을 대입 

   - 실제 원리 : 2차원 배열을 데이터로 받을 수 있는 참조 변수 ar이 먼저 int[행]의 참조값을 받고, 
                 int[행]은 다시 입력된 열의 크기 만큼의 메모리 방을 가리키고 있는 상태.
                  
   - 초기화 : ex. int[][] ar = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
                    → 이렇게 값을 입력하면 컴파일러가 알아서 3행 3열 짜리로 배열을 잡아줌
                    
              ex. int[][] ar = { {11},{22, 33},{44, 55, 66} };
                    → 이 배열을 출력하는 방법 ?   이중 for문 필요
                    
		            for(int i = 0; i < arr.length; i++) {		            // 행을 돌리는 for문이므로, arr의 길이는 3행
			            for(int j = 0; j < arr[i].length; j++) {	        // arr[i]의 길이는 각 행에 들어간 열 데이터의
				            System.out.print(arr[i][j] + "\t");	            // 길이 만큼이 됨.
			            }
			            System.out.println();
		            }
                    → 첫번째 for문은 행, 두번째 for문은 열 
                    → cf. 이런 배열은 3행 3열 짜리 배열에 값이 덜 들어가는 것이 아니라, 애초에 값이 1개, 2개, 3개가 들어가는 배열이므로
                          나머지 빈 자리라고 생각되는 부분에 기본값 0이 들어가는 것이 아님.
