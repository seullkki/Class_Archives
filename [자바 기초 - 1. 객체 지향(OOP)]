[자바 기초 - 1. 객체 지향(OOP)]



- 객체(=인스턴스) : 서로 연관되어 있는 상태(= 변수 = 데이터)와 행위(메소드)를 그룹핑한 것 = '부품화'
                      →  로직의 '재활용성'에 객체가 기여함.
                      →  서로 연관성 있는, 중복되는 로직끼리 묶어놓기 때문에, 관련 없는 로직과 구분지을 수도 있음.
                      →  코드 양을 극적으로 줄일 수 있고, 필요한 코드를 쉽게 찾고, 변동 사항을 하나의 수정으로도 넓은 범위에 적용시킬 수 있음
                         

- 객체 지향 프로그래밍 : 객체들을 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것


- 클래스 : 설계도
           → 기본 구성 : 데이터(변수 + 메소드)로 이루어짐
           → 의미 ① 코딩 상 '클래스' : 소스코드 파일(.java)의 이름과 일치하는 코드 상의 클래스
                                      ?? (객체 생성할 때, main이 들어가는 calss 파일)
                  ② 컴파일 후 파일(.class) : 객체 생성할 때, 변수 + 메소드가 들어가 있는 class 파일

- 인스턴스 : 설계도에 따라 만든 제품들 → 만들어진 객체에 서로 다른 값을 넣어서 다른 결과를 출력하는 여러 개의 객체들이 각각 '인스턴스'가 됨   
                                      → 인스턴스 변수 ? 클래스 내에 선언된 변수
                                        인스턴스 메소드? 클래스 내에 선언된 메소드
                                        지역 변수 ? 함수 안에 선언된 변수                                      
                                        
                                        
< 객체를 만드는 방법 >
  1. 클래스 파일 만들기 (.class)
     - 필요한 변수/메소드가 들어있음

  2. 객체를 만들고 + 출력할 파일(main 메소드 있는 클래스) 만들기
     - 객체를 만드는 키워드 =  .class 파일을 메모리로 올리는 키워드 : "new"
     - 객체의 이름은 보통 클래스 이름과 같도록 함


< 객체가 생성되는 과정 >
  1. new 라는 키워드로 객체를 생성하면, 입력한 객체의 이름으로 된 공간이 메모리에 할당됨
  2. 할당된 메모리에는 클래스 파일의 변수들과 메소드들이 자리잡고 있음.
  3. 이 메모리가 "주소"를 부여 받게 됨. (주소를 부여해주는 것은 OS)
  4. 그러면 변수와 메소드가 들어 있는 할당된 메모리 덩어리가 첫번째 주소를 가리키는 상태가 되는데, 이 상태가 "객체 생성".

  → 그래서 객체에 어떤 값을 입력할 때. 값들은 "주소"로 들어가고
       해당 주소 안의 각 변수에 값이 대입됨


< 객체의 데이터 종류 > 
   - 참조형
   - 객체의 크기 : 4바이트(32bit)


+ cf. 정의된 메소드 안에서 출력(println)까지 끝나 모든 동작이 완료되었을 때는, return값이 필요 x.
      그러나 메소드를 호출했을 때 호출부에서 출력을 하려면, 메소드 안에서 모든 동작이 완료되지 않았기 때문에 return값을 주고
      return값으로 활용을 해야하므로 return값이 필요.


+ ex. [객체 설명]
public class Circlesmain {

	public static void main(String[] args) {
		       Circle circle = new Circle();
           ------  ----    ---  ------
             |       |       |      ↓
	           |       |       ↓      생성자 메소드 : '호출' (정의는? Circle 클래스 안에)
             |       ↓    객체(= 인스턴스) 생성 키워드 = ★컴파일된 java 파일(클래스)를 메모리에 올리는 키
             |  변수 이름
             ↓
            데이터 타입 : 클래스 이름
                           / 크기 : 4바이트(32bit 시스템인 자바에서는 주소값을 보내려면 32bit를 다 씀) 
                           / 종류 : 참조형
                           
		circle.setRadius(5);
		     ↓
       circle에 들어가 있는 주소를 찾아가서, 덩어리 안의 setRadius를 찾아 인자를 넣음

		double area = circle.getArea();
               ↓
       8바이트짜리 area라는 이름의 메모리 방을 잡고, circle에 있는 주소를 찾아 getArea에 가서 연산 결과를 다시 area 방에 넣음
             

		System.out.println("넓이는 " + area);
	}
}

   → new 키로 메모리에 올리는 순간, radius / 함수 3개, 총 4개의 방이 각각 8바이트, 각 4바이트로 할당됨.
   → 메모리에 올라갈 때는 radius부터 함수가 순차적으로 올라감.
   → 그리고 OS가 준 주소값을 가짐(각 변수와 메소드마다 주소도 차례대로 붙음)
     + 하나의 클래스로 여러 인스턴스를 생성할 때, 각 인스턴스마다 다른 주소값을 부여함
   → 여기서 첫 번째 주소가 circle이라는 변수에 들어가게 됨
        = 즉, circle이라는 방에 들어가는 값은 첫 번째 주소값           
   → 이렇게 메모리에 할당되어 덩어리의 첫 번째 주소를 가리키고 있는 상태 = 객체 = 인스턴스
   → 참조형도 함수의 매개변수로 올 수 있음
       ex. BankAccount ref = new BankAccount();

           ref.deposit(3000);
           ref.withdraw(300);
           check(ref);

           public static void check(BankAccount acc){
               acc. checkMyBalance();
           }

                           ↓
          acc 이름의 메모리 방도 BankAccount 덩어리의 첫 번째 주소를 가리키게 됨
           + acc는 { } 안에서만 유효한 변수이므로, 실행이 끝나면 acc는 메모리에서 사라짐.
            (그러나 acc만 사라지는 것이지. ref와 덩어리는 그대로 남아 있는 것임)
