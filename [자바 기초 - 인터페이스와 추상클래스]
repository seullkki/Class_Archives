[자바 기초 - 인터페이스와 추상클래스]



 - 자바의 70%는 다형성, 나머지 20%는 인터페이스(역시 상속)
 - 인터페이스를 활용한 다형성을 매우 많이 사용하게 될 것.


 1. 인터페이스
    - 형태 : interface (예전의 'class' 자리) + 인터페이스 이름 { 
		 메소드 호출 = 구현 부분 {} 이 없는 메소드 = " 추상 메소드 "
	     }

		→ ex. interface Printable {
			  public void print(String doc);	------------------------- 구현 부분 { } 이 없는 메소드.
		      }						                          '함수 호출'이 옴.
		→ ★ 구현 부분이 없는 이유 : " abstract public " (원래는 함수 호출부분 맨 앞에 이것이 붙기 때문인데, 생략도 가능)
								 (아무 것도 붙이지 않으면 컴파일러가 알아서 둘을 붙인 상태로 만들어줌)
								 (interface는 무조건 public)
		→ ★ abstract 의미 : " 메소드는 자손이 구현하라 "

    - 특징 ① 객체 생성 X (클래스는 내용이 아무 것도 없이 이름만 있어도 객체 생성이 되지만, 인터페이스는 new 가 안됨.)
		         (이유 ? interface는 생성자 자체가 x)
		         (주의 사항 : 객체 생성은 안되지만, 변수 선언은 가능)
		           → ex. Printable p;   --------------------------------------------- 가능 (타입 : Printable / 크기 : 4바이트)
		                 Printable p = new Printable();  ------------------------- 불가능
				 
	   ② 인터페이스형 참조변수 선언 가능
	      → ex.   Printable prn = new Printer();
		      prn.print("Hello");

	   ③ 이름 규칙 : I + 인터페이스 이름  /  인터페이스 이름 + able
	

     - 사용 방법 : class + 클래스 이름 + implements + 인터페이스 이름 { 구현할 메소드 }
	         → { } 사이의 메소드를 구현하는 것은 '클래스' = 클래스 메소드를 오버라이딩하는 것
	         → interface 만드는 키워드 : implements 
	         → 상속의 extends와 비슷한 기능을 하지만, 상속이 아닌 '구현'을 하는 것.

     - 존재 이유 : extends 가 다중 상속이 안되고 단일 상속만 되기 때문에, 다중 상속을 지원하기 위해 implements를 만듦.
	          = 둘 이상의 인터페이스를 구현 할 수 있음.
	
     - 어떤 상황에 사용할까 ?
        ① 하나의 표준(규약)을 만들어서 (= 인터페이스) 각기 다른 상황을 적용시켜 같은 규격으로 실행되도록 함
	→ 인터페이스에 들어 있는 메소드 (이름 + 매개 변수 타입)을 가지고, 각 클래스마다 implements 해서 같은 이름의 메소드를 만들면,
	  객체 생성 후 클래스 별로 같은 규격을 가진 다른 성격의 메소드를 호출 가능.
        ② implements 후에 객체를 생성해서 메소드를 불러오는 방법은 두 가지 방법으로 가능.
            1) 자손 객체 + 변수 이름 = new 자손 객체();
            2) 부모 객체 + 변수 이름 = new 자손 객체();
 	→ 1보다는 2가 좋은 방법.
	→ 클래스가 비슷한 이름으로 여러 개 생성될 수 있는데, 
	  이걸 객체 생성할 때 2번이면 데이터 타입 + 생성자를 모두 바꿔야 하지만, 1번이면 생성자만 바꿔주면 됨.



      - 인터페이스 안에 들어갈 수 있는 내용
       	→ 상수 : 기본적으로 public이 붙음 / 컴파일러는 public static final이 빠져있다면 자동으로 입력해줌.
	→ 추상 메소드 : 기본적으로 public이 붙음
			                  
			   		         
      - 인터페이스 안의 메소드가 추가되면?
          → 원래 방법으로는 프로그램이 작동하지 x (기존 추상 메소드만 구현되어 있는 상태이기 때문)
          → 인터페이스를 구현하는 클래스는 해당 인터페이스 안의 모든 추상 메소드를 구현해야 하므로, 컴파일 에러남.
          → 해결 방법 : 새로운 인터페이스를 만들고, 기존 인터페이스를 상속받아(extends) 새 인터페이스에 추가된 추상 메소드를 넣어줌.   
			 ( = 인터페이스도 상속 가능)
			 (기존 인터페이스에 추가하면 x. 원래 방식은 기존 추상 메소드만 구현한 형태이기 때문)
			 (새로 만든 인터페이스를 implements 하는 새 클래스는 원래 추상 메소드 + 추가된 추상 메소드를 모두 구현해주어야 함)  

          → 만약 인터페이스가 계속 추가되면 추가되는대로 인터페이스를 만들어 서로 상속하도록 할 수 있음.
	    이것을 간소화하기 위해 '디폴트 메소드'를 제공함.
          → 디폴트 메소드 : 새로 추가되는 추상 메소드의 맨 앞에 'default'를 추가해주고 기존 인터페이스에 추가해주는 방법.
			       (새로 자바에 추가된 문법. 기존 문법 상으로는 어긋나는 부분이 있음)
			       (이 경우 기존 방식처럼 원래 있던 추상 메소드만 implements에도 에러 나지 x.)
			       (+ 새로운 클래스에 인터페이스를 implements 한 후 두 메소드를 오버라이딩하면 됨.)
			       (의미 : 자손이 구현하든 안하든 상관 없다는 의미 = 기존 메소드만 있어도 ok = 기존 + 새 메소드 있어도 ok)				  
			       (특징 : default가 붙은 메소드 안에는 "구현 내용"까지 적을 수 있음 = static 붙은 메소드도 구현 내용 적을 수 있음.)


          → 인터페이스도 instanceof 연산자 사용 가능 : 본인 or 자식 instanceof 본인 or 부모 = true
							(= 형변환 가능한가?의 문제)
							(= 앞에 있는 것이 뒤에 오는 것의 주소를 가지고 있는가?)

       - Marker 인터페이스
          → 의미 : 클래스에 특정 표시를 해두기 위한 목적으로 정의된 인터페이스 / 클래스를 분류해주는 역할
	  	   (여러 서로 다른 특성을 가진 클래스들이 있을 때, 공통된 성질을 가진 클래스들끼리 분류해주기 위해 해당 성질을 이름으로 한
		    빈 인터페이스를 만들어서, 해당 특성을 가진 클래스에 각기 다른 인터페이스 implements를 해주면 
		    일단 어떤 클래스가 어떤 특성을 가졌는지 구분을 해주는 역할을 하면서 + 인터페이스 이름으로 클래스들을
		    instanceof 확인을 해볼 수도 있음.
		    그러면 클래스가 아무리 많아도 마킹으로만 수 백개의 클래스도 instanceof 확인을 할 수 있음)
	        
          → 형태 : interface Upper/Lower { }
	           (구현할 메소드가 없는 형태가 흔함)
		
          → 사용 방법 : implements 문장, Upper / Lower{
				클래스 내용
			}
			
          → ex.  
        




 2. 추상 클래스
   - 형태 : public abstract + class + 클래스 이름 {
		메소드 {
	}

		추상메소드 ( = public abstract void 메소드 이름(); )
	}

	→ 즉, 추상 메소드를 가진 클래스에 반드시 'public abstract'를 붙여줘야 한다는 의미

   - 의미 : 추상 클래스의 추상 메소드를 구현하려면 다른 자손 클래스가 구현해줘야 함.

   - 특징 : 참조 변수 선언은 가능 / 인스턴스 생성 불가능
 
   - 인터페이스와 추상 클래스의 차이? 전에 비해 굉장히 모호해짐. 그래도 인터페이스를 쓰는 쪽이 좋음.


 
 *cf. 공통으로 쓸 변수와 메소드가 있는 경우, 인터페이스보다 추상 메소드를 사용하는 것이 편함.
 *cf. 오버라이드할 때, 각 클래스의 오버라이드한 메소드에 public을 꼭 써야함 - 왜??
