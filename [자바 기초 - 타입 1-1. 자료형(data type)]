[자바 기초 - 타입 1-1. 자료형(data type)]


* 특징
 - 정수는 int로, 실수는 double로 자동 형변환 됨
    → 원인 : java는 기본이 32bit 체제로 만들어짐. 즉, RAM과 CPU가 데이터를 주고받을 때 총 32개의 선으로 통신함. 
             그런데 byte는 필요한 칸이 8개(8bit), short는 16개(16bit). 아무리 32개보다 적은 선을 
             필요로 하는 데이터여도 무의미한 선들은 반드시 0을 보내 처리하도록 되어 있음.
             이것은 CPU에 int 메모리 크기로 인식되기 때문에, byte와 short는 자동으로 int 형변환 됨.

 - 입력한 데이터타입과 맞지 않는 데이터를 입력하게 되면 '오버플로우', '언더플로우' 발생
   (전혀 다른 값이 저장됨)

 - 실수형은 정수형과 같은 메모리 크기를 할당 받아도 표현할 수 있는 수의 범위가 더 넓음
    → 원인 : 실수형은 컴퓨터에서는 반드시 오차가 나오게 됨. 왜냐하면 실수는 무한한 수인데 그것을 유한한 메모리에 담으려 하기 때문.
             (= 무한한 실수 전체를 다 담을 수가 x)
             그래서 찾은 방법은 메모리에 들어갈 수 있는 실수의 최소, 최대값을 정해놓고 그 사이에
             들어가는 어떤 실수를 찾을 때, 정확히 그 실수값이 아니라 가장 근접한 값(근사값)을 해당 실수라고 하도록 함.
             때문에 정확한 실수값이 아닌 오차가 존재하는 근사값을 사용하므로 오차가 늘 있음.
               
               
    → 실수가 들어가는 최소, 최대값의 범위가 넓어지면 오차 범위도 넓어짐.
      실수가 들어가는 최소, 최대값의 범위가 좁아지면 오차 범위도 좁아짐.
        
    → 실수형 float과 double 중 어떤 것을 선택할 것인지는 '정밀도'를 기준으로 함
        double형의 표현범위가 더 넓기 때문에 실수형은 자동으로 double 형변환됨.
        ( 여기서 말하는 '정밀도'란 실수 하나를 표현할 때의 정밀도를 의미하는 것. 연산했을 때의 정밀도 x )

 - 음의 정수 표현 방법 : 1의 보수 (2진수의 각 자릿수가 1이 되기 위해 보충해야 하는 수 = 양의 정수 2진수를 거꾸로 뒤집음)
                         + 1     
                                    → 양의 정수 + 음의 정수 결과값의 8비트가 넘어가는 자릿수는 버림
                                    → ex. int num1 = -10; 은 num1에 양수 10을 2의 보수법으로 바꾼 후 2진수를 대입한다는 의미
                                                                   

< 정수형(할당 메모리 크기) >
 ① byte (1바이트)
 ② short (2바이트)
 ③ int (4바이트) : +- 21억
 ④ long ( 8바이트)


< 실수형 >
 ① float ( 4바이트) : 소숫점 6자리까지 표현
 ② double( 8바이트) : 소숫점 15자리까지 표현

  → 단순 실수의 표현의 경우에는 각 자릿수만큼 표현이 되지만, 두 개 이상의 실수 간 '연산'을 진행하면 무조건 오차가 발생하게 됨
    = 각 표현 자릿수보다 더 작은 자릿수에서도 오차가 발생할 수 있음
    
  → cf. 그래서 실무에서는 소수점이 나오는 경우, 고객과 협의를 통해 소수점 어디까지 표현하고 버릴 것인지 정함
  → cf. 정수형과 실수형을 따로 나눠놓은 이유 : 정수형을 2진수로 표현하는 방법과 실수형을 2진수로 표현하는 방법이 서로 다르기 때문
                                                      

< 문자형 >
 ① char (2바이트)
   → 문자를 인식하지 못하는 컴퓨터가 문자형을 처리하는 원리는 각 문자마다 번호를 매겨서(인코딩), 그 번호를 다시 2진수로 바꿔 메모리에 올리는 것.
     그렇게 처리된 2진수를 다시 번호로 바꿔 문자로 표시하면(디코딩) 출력이 문자 형태로 됨.
   → cf. 이렇게 문자를 출력할 때, 운영체제에 있는 픽셀표의 폰트를 찾아 같이 출력됨.
   
   → 이를 위해 만든 것이 아스키 코드( 각 문자는 숫자와 일대일 매칭 형태 ) (영어만)
    【 '자바'에서는 문자를 "유니코드(2바이트)"로 표현함】
       
   → 문자형 데이터는 이렇게 사실상 숫자를 문자처럼 보여주는 것이므로, 문자끼리 연산하면 문자가 출력되지 않고 숫자가 출력됨.
       
   → ex. System.out.println('고' + " " + '가'); -------------------------------- 고 가
                                                                           (중간에 문자열이 들어가면 연산 x)
         System.out.println('고' + '가'); ------------------------------------- 88320
                                                                           (문자 + 문자는 인코딩 되어 연산됨)
         System.out.println('고' + ' ' + '가'); --------------------------------- 88352
                                                                           (공백 코드 32 추가)
         System.out.println(' '); -------------------------------------------- 

           + 문자 ' '(공백, space)의 아스키코드 = 32
           + 따라서 ' '이 연산 중간에 들어가면 숫자로 연산됨(2, 3번 예시)
             그러나 ' '이 단독으로 있을 때는 문자로 디코딩 (4번 예시)

           + ★ 'A' + 'A' 는 +라는 연산이기 때문에 두 리터럴을 각각 메모리로 올려 CPU가 연산을 해야 함.
               이때, 메모리의 데이터타입은 char 에서 int 형으로 '자동 형변환' 되면서 문자가 출력되지 않고 연산이 이루어지게 됨.
               (ex.  char ch = 'B';    를 문자가 아닌 66으로 출력하는 방법?
                      → System.out.println((int)ch);                 문자가 아닌 정수형으로 형변환
                      → System.out.println((+ch);                                                     )
           
   cf. char 라는 데이터타입이 붙는다는 것은 일종의 암호를 푸는 과정이 포함된 사인이라고 생각하자

< 논리형 >
 ① boolean( 1바이트) : true (1) / false (0)
